function  dat = cs_read(filename,rcIdx,vb)% CS READ - CODAR cross spectra file reader% dat = cs_read(filename,rcIdx,vb)%% INPUT:% filename	- Input Cross Spectra file name as an ASCII string or cell%			  e.g. 'CSA OSU2 97/05/20 1200'% rcIdx     - optional array of range cells indecies to load%             (eg 1, 24, [5 9:12], etc)% vb        - verbosity switch ('true' or 'false' logical if used as%               2nd input)%% OUTPUT% DAT data structure containing:%% DAT.Header substructure:%	dateTimeSec04		- Date/Time of data in seconds since 1/1/1904%                         (For CSQ refers to the start time of the file,%                         for CSA and CSS refers to the center time).%	kindOfData			- Kind of data %							=1 => Unaveraged cross spectra%							=2 => Averaged cross spectra%	siteStr				- Site designation (4 characters), e.g. 'PPin'%	averagingTimeMin	- Averaging time in minutes (default 60 min)%	freqMHz				- Tx Start Frequency in MHz (default 12 MHz)%	SwRfreqHz			- Sweep repetition frequency in Hz (default 2 Hz)%	SwBWkHz				- Sweep bandwidth in kHz (default 50 kHz)%	sweepUpDown			- Sweep up(=True) or down(=False) (default False)%	nRangeCells			- Number of range cells %						     (default 32 for unaveraged, 31 for averaged)%	firstRangeCell		- First range cell (default 0)%	distToFirstRangeCell- Distance to first range cell in km%% CROSS SPECTRA DATA%   They are matrices with size [nFFT,nRangeCells]%	antenna1Self		- Antenna#1 self spectra   (NFFT x NRC)!!%	antenna2Self		- Antenna#2 self spectra %	antenna3Self		- Antenna#3 self spectra %	antenna12CrossSp	- Antenna#1*conj(Antenna#2)) cross spectra (complex)%	antenna13CrossSp	- Antenna#1*conj(Antenna#3)) cross spectra (complex)%	antenna23CrossSp	- Antenna#2*conj(Antenna#3)) cross spectra (complex)%	spectraQualNum		- Spectral quality numbers (0.0 to 1.0) these are used %						  only with the averaged cross spectra. They represent%						  the fraction of unaveraged spectral values removed at%						  bin over the (hour) averaging period due to ship or%						  interference rejection procedures.%						- If this number drops below 0.5 (50%), a minus sign%						  is placed in front of 'antenna3Self' as a flag to%						  suggest this bin not be used for subsequent processing%						  because the data is too stale.  The minus can be ignored.%%  rCellIdx             - contains the actual range cell values, also known as the%                         indecies of the *FULL* file. Different than the%                         column indexing when only parts of the file are%                         read.%% EXAMPLE% fn = '/m_files/test_data/compute_apm_from_csq/CSQ_cop1_08_12_06_205124.cs';  % dat = cs_read(fn,':',1); %keyboard%%% NOTES% See File_CrossSpectra.pdf for reference% Includes an optional test case invoked as follows:% >> dat = cs_read('--t');% Modified from COS's ReadCS.m by Brian Emery. % Copyright probably still applies .... %% Original by   Jimmy Isaacson%  jimmy@codaros.com%% April 2011 Major mods by Brian Emery (renamed cs_read.m):%   - added ability to load selection of range cells%   - lots of refactoring (to divide + conquer)%   - added robust test cases     % November 2011 Updates for transpose operator% NOTES% float32 is 4 Bytes per element, we load 9 range cells by default, % with nfft length (usually 512) elements, 9*512*4 = 18432 Bytes per % range cell% TO DO% expand to CSS and CSA (averaged) filesif nargin < 3, vb = 0; end% optional test caseif strcmp(filename,'--t'), test_case, dat =[]; return, end% Recurse if filename is multi-element cell input% needs preallocation, rcIdx optionalif iscell(filename)    for i = 1:numel(filename)                if nargin < 2,                        dat(i) = cs_read(filename{i});        else                        dat(i) = cs_read(filename{i},rcIdx);                    end    end    returnend% Open file read onlyfid=fopen(filename,'r','b'); % Read in header data[Header,nfft,nRangeCells] = read_header(fid);%--------------------------------------------------------------------------------% INITIALIZE%--------------------------------------------------------------------------------% Init output matricies and position file pointer if necessary    % If range cells list given, re-determine number of range cells to load% allow ':' input for rcIdxif nargin > 1 && ~islogical(rcIdx) && ~ischar(rcIdx)            % max sure rcIdx is less than the max number of range cells    rcIdx = rcIdx(rcIdx <= Header.nRangeCells);    % now determine number of range cells to load    nRangeCells = length(rcIdx);          end% Setup and zero out matrices[antenna1Self, antenna2Self, antenna3Self,  ...    antenna12CrossSp, antenna13CrossSp, antenna23CrossSp, ...        spectraQualNum ] =  deal(zeros(nfft,nRangeCells));%--------------------------------------------------------------------------------% Read in cross spectra data%--------------------------------------------------------------------------------% Begin loopfor rc = 1:nRangeCells        % only use fseek if reading subset of data    if nargin > 1 && ~islogical(rcIdx) && ~ischar(rcIdx)                        % position pointer (-1 = begining of file)        s = fseek(fid, 72 + ((rcIdx(rc)-1)*9*4*nfft) ,-1);                % catch errors in fseek and rcIdx        pointer_err_chk(s,fid)            end                % Read in self spectra data    antenna1Self(:,rc) = fread(fid,nfft,'float32');      antenna2Self(:,rc) = fread(fid,nfft,'float32');     antenna3Self(:,rc) = fread(fid,nfft,'float32');         % Read in cross spectra data; real and imaginary separately    antenna12CSp = fread(fid,[2,nfft],'float32').';      antenna13CSp = fread(fid,[2,nfft],'float32').';     antenna23CSp = fread(fid,[2,nfft],'float32').';         % Combine real and imaginary cross spectra data    antenna12CrossSp(:,rc) = antenna12CSp(:,1)+1i*antenna12CSp(:,2);    antenna13CrossSp(:,rc) = antenna13CSp(:,1)+1i*antenna13CSp(:,2);    antenna23CrossSp(:,rc) = antenna23CSp(:,1)+1i*antenna23CSp(:,2);        % If averaged data, read in spectral quality numbers    if Header.kindOfData == 2                spectraQualNum(:,rc)=fread(fid,nfft,'float32');                % Byte count will change if using averaged data        % ... I think the 9 gets changed to a 10 ...        error('codar:cs_read','Byte count may change! CANT DO CSAs YET')            endend% Close filestatus = fclose(fid);if status ~= 0    error(error_messages(7))end%--------------------------------------------------------------------------------% Finalize Outputs%--------------------------------------------------------------------------------% dat = cs_struct(1); % need to add this?% Pack data into structurevars ={'Header','antenna1Self','antenna2Self','antenna3Self', ...       'antenna12CrossSp','antenna13CrossSp','antenna23CrossSp','spectraQualNum'};   dat = struct_pack(vars);% inform user if verbosity if vb, disp(['loaded ' filename]), end% keep range cell index if only a subset of dataif nargin > 1 && ~islogical(rcIdx)   dat.rCellIdx = rcIdx(:)'; end% Other meta datadat.FileName = filename;end% ----------------------------------------------function pointer_err_chk(s,fid)% POINTER ERR CHK% catch errors in fseek and rcIdx if s < 0    [mess,errnum] = ferror(fid);    error(mess)endend% ----------------------------------------------function [H,fftLength,nRangeCells] = read_header(fid)% READ HEADER %  Read in header data% hex2dec is slow, convert once but keep around for reference% these are the 'number of Bytes until data'curVersNo=4;curNbytesA = 62; % hex2dec('3E');curNbytesB = 56; % hex2dec('38');curNbytesC = 48; % hex2dec('30');curNbytesD = 0;  % hex2dec('00');H.rdCSErr = 0;% Read in specific header data (Order dependent)H.versNo = fread_chk(fid,'int16',curVersNo,1);dTHex = fread(fid,4,'uchar');H.dateTimeSec04=dTHex(4)+dTHex(3)*256+dTHex(2)*(256^2)+dTHex(1)*(256^3); H.NbytesA = fread_chk(fid,'int32',curNbytesA,2);H.kindOfData = fread_chk(fid,'int16',2,3,@gt);H.NbytesB = fread_chk(fid,'int32',curNbytesB,4); H.siteStr = char(fread(fid,4,'uchar')'); H.NbytesC = fread_chk(fid,'int32',curNbytesC,5);H.averagingTimeMin = fread(fid,1,'int32');H.deleteRawSpectra = fread(fid,1,'int32');H.overrideRemHeader = fread(fid,1,'int32');H.freqMHz = fread(fid,1,'float32');H.SwRfreqHz = fread(fid,1,'float32');H.SwBWkHz = fread(fid,1,'float32');H.sweepUp = fread(fid,1,'int32');fftLength = fread(fid,1,'int32');nRangeCells = fread(fid,1,'int32');H.firstRangeCell = fread(fid,1,'int32');H.distToFirstRangeCell = fread(fid,1,'float32');H.NbytesD = fread_chk(fid,'int32',curNbytesD,6);H.dTHex = dTHex;H.fftLength = fftLength;H.nRangeCells = nRangeCells;% % Get variables list and pack them into a structure% hflds = {'dateTimeSec04','kindOfData','siteStr','averagingTimeMin', ...%     'freqMHz','SwRfreqHz','SwBWkHz','sweepUp','nRangeCells', ...%     'firstRangeCell','distToFirstRangeCell','dTHex','deleteRawSpectra',...%     'overrideRemHeader','fftLength'};% % H = struct_pack(hflds);end% ----------------------------------------------function versNo = fread_chk(fid,type,testVal,errNum,fxn)% FREAD CHECK - file read with error checking%% Replaces, for example:% versNo=fread(fid,1,'int16');% if versNo ~= curVersNo%   rdCSErr=1;%   disp('return at line 76'),return%   %   error(ERR(1))%   % end% Set test function to 'not isequal' by defaultif nargin < 5, fxn = @not_is_equal; end% Data fields to read fixed at 1versNo = fread(fid,1,type);if fxn(versNo,testVal)    error(error_messages(errNum))endend% ----------------------------------------------function tf = not_is_equal(a,b)tf = not(isequal(a,b));end% ----------------------------------------------function ERR = error_messages(n)% ERROR MESSAGES% get error message structure%% =  0 => No error% =  1 => Bad Version Number% =  2 => Header field 3 not correct% =  3 => Kind of data (field 4) not =1,2% =  4 => Header field 5 not correct% =  5 => Header field 7 not correct% =  6 => Header field 19 not correct% =  7 => File close errorERR(1).msgid   = 'codar:cs_read:bad_version_number';ERR(1).message = 'Input file is an invalid version or type.';ERR(2).msgid   = 'codar:cs_read:bad_header_field';ERR(2).message = 'Header field 3 not correct.';ERR(3).msgid   = 'codar:cs_read:bad_kind_of_data';ERR(3).message = 'Kind of data (field 4) not = 1 or 2.';ERR(4).msgid   = 'codar:cs_read:bad_header_field';ERR(4).message = 'Header field 5 not correct.';ERR(5).msgid   = 'codar:cs_read:bad_header_field';ERR(5).message = 'Header field 7 not correct.';ERR(6).msgid   = 'codar:cs_read:bad_header_field';ERR(6).message = 'Header field 19 not correct.';ERR(7).msgid   = 'codar:cs_read:bad_file_close';ERR(7).message = 'File close error.';ERR(8).msgid   = 'codar:cs_read:bad_file';ERR(8).message = 'Some File Error';ERR = ERR(n);end% ----------------------------------------------function check_flds(dat,old)% Some code to verify that the data is the same% % if rCellIdx is present, it will check that % a subset of range cells from the old data is the% same as the subset of new data.% Check the headerif ~isequal(dat.Header,old.Header)    disp('difference between cs_read and ReadCS.m HEADERS detected')    % keyboardend% Get fields except for the Headerfld = setdiff(fieldnames(old),{'Header','FileName'});% get indexingif isfield(dat,'rCellIdx')    rx = dat.rCellIdx;else    rx = ':';end% Run the checkfor i = 1:numel(fld)        if ~isequal(dat.(fld{i}),old.(fld{i})(:,rx))        disp('difference between cs_read and ReadCS.m detected')        keyboard    end    end% if we get here all the test passeddisp('TESTS PASSED')end% ----------------------------------------------function test_case% TEST CASE for cs_read.m%% datestr(datenum(1904,1,1)+(dateTimeSec04/86400))% TEST FOR A BAD FILE READ% I want the error message, fn = '/m_files/test_data/cs_read/CSQ_cop1_08_12_06_200428.cs';rc = 33;dat = cs_read(fn,rc,1);% Get cs test filenamefn = '/m_files/test_data/compute_apm_from_csq/CSQ_cop1_08_12_06_205124.cs';  % fn = {'/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_205124.cs'; ...%       '/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_203836.cs'; ...	%       '/Data/testData/compute_apm_from_csq/CSQ_sci1_10_09_01_000351.cs'; ...%       '/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_204252.cs';}% fn = '/Data/testData/simulatedArchive/ssd1/CSS/2008_01/31/CSS_ssd1_08_01_31_1000.cs4'; % fn = '/Data/testData/cs_read/CSA_SHEL_09_07_30_1900.cs';% RUN BASIC TEST% Load all data, compare old and new output to verify dat = cs_read(fn,':',1); %keyboard% get ReadCS output for comparisonold = ReadCS(fn);% remove rdCSErr fieldold = rmfield(old,'rdCSErr');dat.Header = rmfield(dat.Header,'fftLength');% check all is samecheck_flds(dat,old)% RUN COMPLEX TEST% Now load subset of range cells and see how they comparerc = [5:6 15] ;dat = cs_read(fn,rc); % check all is samecheck_flds(dat,old)% Make figuresfor i = 1:numel(rc)        figure    % Plot ReadCS data    plot(1:512,real(10*log10(old.antenna12CrossSp(:,rc(i)))),'-r'), hold on        % Plot subset'd data    plot(1:512,real(10*log10(dat.antenna12CrossSp(:,i))),'b.')        title('Old method (-r), New method (b.)')    end% NEED A TEST FOR CELL FNAME INPUTkeyboardend